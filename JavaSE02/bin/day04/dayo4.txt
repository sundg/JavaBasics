FilterInputStream 高级流的父类

用于对象序列化与反序列化的流
	ObjectInputStream：对象的反序列化
	ObjectOutputStream：对象的序列化
	通常我们序列化对象是用于保存对象和传输对象
	
	
	
	
	
	
Java多线程                                                                                                    
	java语言的一个优势就是处理多线程比较简单
	
在一个操作系统中会同时运行多个任务(程序)，例如：qq、IE、LOL、百度等
	1、在操作系统中同时运行的没一个任务都是一个进程
	2、对于一个进程(程序)而言，在程序内部也会同时运行多个任务，那么每一个任务称为一个线程
	
	线程都是并发执行的，所谓并发：宏观上所有的线程都是同时运行的，微观上看所有的线程都是走走停停
	
线程的调度：
	将CPU的时间划分为若干个片段(时间片段)，尽可能的均匀分配给每一个线程，获得CPU时间片段的线程将得以被CPU执行
	
	线程调度
	CPU
	线程
	时间片段	
	
创建线程的两种方式：
	1、继承Thread类
	2、实现Runnable接口
	Thread类     线程类
	其每一个实例表示一个可以并发的线程
	使用线程的注意事项：
		对于线程调度而言，分配的时间片段长短，具体分配给哪一个线程时间片段对于程序而言都是不可控的
	
	
线程在执行某段逻辑时，可能会发生阻塞现象
	Sleep阻塞
		该阻塞可以指定阻塞时间，并在线程阻塞了该时间后自动
		返回Runnable状态，Thread提供了一个静态的方法sleep(),
		该方法就是用于睡眠阻塞的
	Wait
	
线程在以下情况会停止：
	1、run方法正常执行完毕
	2、run方法执行过程中抛出了一个未捕获的异常(中断异常)
	
进程的停止：
	当一个进程中的所有的前台线程停止后，该进程结束
	
	前台线程和后台线程：setDaemon()
		后台线程的特点：用法与前台线程无异，只是当一个进程中所有的前台线程都结束后，
					     无论后台线程是否还在运行中都被强制结束，从而使得进程结束，程序退出
		后台线程：也称为守护线程，精灵线程
			如：在运行我们程序时，操作系统会启动一个进程来运行JVM，JVM运行后创建一个前台线程来
				运行我们的main方法，同时也会创建一个后台线程来运行GC(垃圾回收)
	
线程的优先级：线程的优先级被划分为1-10
	void setPriortity(int p)
	1最低，10最高
	优先级越高的线程被分配的时间段的机会就越多，那么CPU执行的机会就越多
	
	
线程安全：
	多线程并发访问同一资源时，会产生线程安全问题
	解决办法：把异步操作变为同步操作
		1、多线程并发读写同一个临界资源会发生"线程安全并发问题"，
		      若果保证多线程同步访问临界资源，就可以解决线程安全问题
		2、常见的临界资源：
			a、多线程共享的实例变量
			b、静态公共变量
		3、异步：各干各的，执行没有先后顺序 Ajax
		      同步：你干完我干，执行有先后顺序
		4、同步锁：synchronized关键字
			synchronized可以修饰方法，当一个方法被修饰后，这个方法就是同步方法，
			同一时刻只能有一个线程访问该方法
			
		  synchronized同步块
		  	当一个方法被修饰后，该方法变为同步方法，虽然保证了代码的执行安全，但是效率低下，
		  	我们实际上只需要将方法需要的同步的代码片段加上锁，这样可以缩小同步范围，从而提
		  	高代码的运行效率
		  	结构：
		  	synchronized(同步监视器){
		  		需要同步的代码片段
		  	}
		  	同步监视器就是一个对象，任何对象都可以
		  	但是要保证一点，多线程看到应该是"同一个"对象，通常情况下，使用this就可以了
	
	
	
非线程安全                          线程安全
StringBuilder			StringBuffer
ArrayList 				Vector
HashMap					HashTable
HashSet		...
对于集合(Collection)和Map而言
	Collections类提供了可以将给定的集合转换为线程安全的集合方法
	
	
	
线程的协同工作 	join()	  wait()/notify()
	
	
	
	
	
	
	
	
	
	
	
	
	